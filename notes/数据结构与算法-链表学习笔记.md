#### 数据结构与算法-链表学习笔记

##### 什么是链表

- 和数组一样,是一种线性表;
- 从内存结构上看,链表的内存结构是不连续的内存空间,是将一组零散的内存块串联起来，从而进行数据存储的数据结构;
- 链表中每个内存块被称为节点Node,节点除了存储数据外,还需记录链上下一个节点的地址,即后继指针next;

##### 链表的特点

- 插入删除数据的效率高（只需更改指针指向），时间复杂的为O(1)，随机访问效率低（需要从链头开始遍历），时间复杂度为O(n)
- 和数组相比，内存空间消耗更大，因为每个存储数据的节点都需要额外的空间存储后继指针。

##### 常用链表

- `单链表`

  （1）每个节点只包含一个指针,即后继指针；

  （2）单链表有两个特殊的节点,即首节点和尾节点。用首节点地址表示整条链表，尾节点的后继指针指向空地址null。

  （3）性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)

- `循环链表`

  （1）除尾节点的后继指针指向首节点的地址外均与单链表一致

  （2）适用于存储有循环特点的数据

- `双向链表`

  （1）节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）

  （2）首节点的前驱指针prev和尾节点的后继指针均指向空地址。

  （3）性能特点：

  和单链表相比，存储相同的数据，需要消耗更多的存储空间。

  插入、删除操作比单链表效率更高O(1)级别。

  以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。

  对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。

  对于一个有序链表，双向链表的按值查询效率要比单链表高一些。因为我们可以记录上次查找的位置p，每一次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。


##### 与数组的区别

- 从底层存储结构上看:

`数组`需要一块连续的内存空间来存储,对内存要求比较高;

`链表`不需要连续的存储空间,它通过指针将一组零散的内存块串联起来使用;

![img](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

- 插入、删除和随机访问的时间复杂度

`数组`的插入和删除的时间复杂度为O(n)，随机访问的时间复杂度为O(1)

`链表`的插入和删除的时间复杂度为O(1)，随机访问的时间复杂度为O(n)

- 数组的缺点

  （1）若申请的内存空间很大，如100M，若内存空间没有100M的连续空间时，会申请失败，尽管内存可用空间可能超过100M

  （2）大小固定，若存储空间不足，需进行扩容，扩容需要进行数据复制，复制的过程很耗时

- 链表的缺点

  （1）内存空间消耗更大，因为需要额外的空间存储指针信息

  （2）频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。在java语言中则会造成频繁的GC操作

- 如何选择

数组操作简单，实现上使用连续的内存空间，可借助cpu的缓冲机制预读数组中的数据，所以访问效率高；

链表在内存中不是连续存储，所以对cpu缓存不友好，没法预读。

若代码对内存的使用苛刻，则数组合适



##### CPU缓存机制

为什么数组更适合借助cpu缓存预读数据？

CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中。而CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。这样就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入。

对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把以后的几个下标元素也加载到CPU缓存这样执行速度会快于存储空间不连续的链表存储。